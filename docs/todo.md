# Todo

v0.1, goal: end of january 2021

- [x] restructure repo
	- [ ] add an example (using swa)
	- [x] move everything else into src (maybe api.h to include/?)
	- [x] decide on license and add it
	      pro GPL: no one has to link this layer so it would not have a negative
		    impact on anyone. And using GPL it would prevent abusive usage (such as 
			forking/privately improving and selling it)
		  pro MIT: companies are probably still wary about using GPL software
		    and i totally don't have a problem with this being used for
			proprietary software development (such as games). 
			But otoh, companies not understanding licensing and open source 
			should not be my problem.
		  {yep, going with GPL for now}
- [x] switch to shared pointers for device handles, keeping them alive
	  NOTE: nope, not doing that for now. Explicit resource connection tracking
	  implemented though.
- [x] store for handles in which command buffers they were used and set the
      command buffer to invalid state when they are changed/destroyed
- [ ] cleanup Renderer/Gui implementation: merge back together
	- [ ] proper gui sync implementation
	- [x] move gui tabs into own classes
- [ ] display command buffer state in resource UI
- [x] display in UI whether resources are destroyed or not
	  {NOTE: nvm, we decided against shared_ptr approach and never have destroyed resources}	
- [x] fix bug for cmdExecuteCommands when executed command buffers are invalid/destroyed
- [x] Remove Device::lastDevice api hack. Instead return a dev handle from fuenLoadApi
      Should probably just store it inside the api struct.
- [ ] Implement missing resource overview UIs
- [x] Switch to a more useful fork/branch of vkpp: Generate vk::name
      functions for plain vulkan enums, don't use anything else here.
	  Probably best to not even include vkpp as subproject, just copy
	  /dispatch and /names here.
	  	- [x] nvm, should probably just ditch vkpp all together and use the layer utils
		- [ ] check if we can use more of the the layer utils
		      maybe we can replace our own hash table?
- [ ] fix our global dispatchable handle hash table. Either use the vk_layer
	  one or remove the type hashing (dispatchable handles are globally unique).
- [ ] Add more useful overview. Maybe directly link to last submitted command
      buffers?
- [ ] properly shutdown everything, no leftover resources and layer warnings
- [x] proper queue creation and querying for window display
- [ ] properly shut down rendering thread for own-window display
- [ ] test display window for compute-only applications
	- [ ] come up with something smart to block them before they shut down. 
	      Is there a sensible way to do this in the layer or should applications
		  do it themselves? write wiki post
- [ ] proper shipping and installing
	- [x] make the json file a config file, generated by meson
	- [ ] simple wix windows installer, just needs to install prebuilt layer,
	  	   json file and add the registry file. Should probably also install
	       api header tho
		   (maybe for later, >0.1.0?)
	- [ ] write AUR package (maybe for later, >0.1.0?)
	- [ ] write wiki post on how to build/install/use it
- [ ] write small wiki documentation post on how to use API
	- [ ] could explain why it's needed in the first place. Maybe someone
	      comes up with a clever idea for the hooked-input-feedback problem?
- [ ] improve UI
	- [ ] Add proper image viewer
	- [ ] Add proper buffer viewer
- [ ] imgui styling
	- [ ] use custom font
	- [ ] go at least a bit away from the default imgui style
- [ ] full support of all vulkan 1.0 commands
	- [ ] should probably also support the easy-to-support extensions
	      for resource creation already. At least widely used/important extensions
	- [ ] at least make sure it does not crash for features we don't
	      implement yet (such as sparse binding)
- [ ] probably rather important to have a clear documentation on supported
      feature set, extensions and so on
	- [ ] clearly document (maybe already in README?) that the layer
	      can crash when extensions it does not know about/does not support
		  are being used.
- [ ] fully implement command buffer viewer
	- [ ] support all vulkan 1.0 commands (add to cb.h and commands.h)
	- [ ] show all commands & info for commands
	- [ ] better resource selection/collapsing etc
- [ ] properly implement layer querying functions
- [ ] track and show dynamic graphics pipeline state
- [ ] support for buffer views


not sure if viable for first version:
- [ ] stress test using a vulkan-based game. Test e.g. with doom eternal

Possibly for later, new features:
- [ ] (somewhat high prio tho) add support for waiting for command buffer
      recording to finish (with a timeout tho, in which case we simply display
	  that is currently being recorded (and that it takes long)), when viewing
	  it. Especially a big problem for display-window (compared to overlay)
	  when an application re-records in every frame.
	  	- [ ] could be done via conditional variable in command buffer
		      that is signaled on endCommandBuffer
- [ ] handle command-buffer re-recording as graceful as possible.
      	- [ ] Try to match selected command in new state
		- [ ] give visual/explicit feedback about re-recording though.
		      maybe show time/frames since last re-record?
			  Show statistics, how often the cb is re-recorded?
- [ ] way later: support for sparse binding
- [ ] we might be able (with checks everywhere and no assumptions at all, basically)
      to support cases where extensions we don't know about/support are used.
	  (e.g. image is created via a new extension, we don't hook that call,
	  image is then used somewhere). Evaluate if it is doable. If so, we should
	  really try. Even if we don't catch all cases it will make this a lot
	  easier to maintain (and make it seem less of a buggy mess to users)
- [ ] support vulkan 1.1 (non-crash)
	- [ ] fully support everything in UI
- [ ] support vulkan 1.2 (non-crash)
	- [ ] fully support everything in UI
- [ ] support as many KHR extensions as possible (non-crash)
	- [ ] support UI for them where not too much work
- [ ] support khr ray tracing extension
- [ ] support all other extensions (non-crash)
- [ ] interactive 3D cubemap viewer
- [ ] interactive 3D model viewer
- [ ] insert command buffer timing queries
- [ ] per-drawcall image visualization using the inserted subpass + 
      input attachment shader copy idea, if possible
- [ ] even log showing all queue submits
	- [ ] optionally show resource creations/destructions there as well
- [ ] resource and queue freezing
	- [ ] something like "freeze on next frame/next submission"
- [ ] track query pools
- [ ] track buffer views
- [ ] better pipeline state overview of inputs, stages, outputs
	- [ ] maybe via a graph?
- [ ] we might be able to properly hook input (without needing the public api)
	  by using a (movable?) child window for our overlay instead of directly
	  presenting to the swapchain.
